---
layout: post
title:      "Necessity - The Mother of Invention"
date:       2019-10-26 20:30:12 +0000
permalink:  necessity_-_the_mother_of_invention
---


I've been studying for the last several months for a series of exams that I need to pass in order to get a major promotion at work.  Some of the topics are very generic in nature and and the information related to those topics is pertinent across the industry.  Other topics are specific to individual company/site configurations.  There is a very useful online quiz tool for the generic topics that I used extensively for studying those topics.  I did very well on the exams related to the topics I studied using the online tool, but soon I'll be taking exams on the more specific topics.  

As it so happens, right about the time I was wishing that I had a quiz tool for these specific topics, it came time for me to come up with a plan for my JavaScript with Rails project.  The timing couldn't have been more perfect.  I've heard Avi say in many recorded lessons to  "write using the code you wish you had."  To build off of that logic, I've decided to write the app I wish I had for my project.

The project is a simple quiz app which allows users to select topics and to take multiple choice quizzes on those topics.  The questions will be generated by users and the results of every user/question interaction will be stored in a database so that user performance statistics can be viewed.  

On the technical side, the app uses a Rails API backend and a JavaScript/HTML frontend.  The backend models are:
* User
* Encounter
* Question
* Topic
* Quiz

A User has many Encounters and has many Questions through Encounters.  A Question has many Encounters and has many Users through Encounters.  A Topic has many Questions.  A Quiz also has many questions.  Of these models, all are persisted to the database except for Quizzes.  There is no need to persist quizzes because all relevent data is already stored as Encounters.

For me, the most difficult part of building the app was making sure that asynchronous functions had their promises resolved before attempting to use the promised data.  It made it necessary to repeat a lot of code, which then made it necessary to consolidate that repeated code into functions in attempt to make the code DRYer.  Looking at my project, which is currently working, I can see that I could keep refactoring for days to ensure that I'm doing everything in the ways that make the most sense to me.

Although I'm going to keep refactoring, I've built an app that I can be proud to call my own.  I hope to deploy a version of  this app soon so I can start using it to study.
